@persist EGP_WINDOWS:table
@persist EGP_FOCUSED:table
@persist [EGP_CURSOR, EGP_CURSOR_BLINK]:number

#include "library/table"

if(first() || dupefinished()) {
    EGP_FOCUSED = notable()
    
    function string table:egpClass() {
        if(This:egpValid()) {
            return This["properties", table]["class", string]
        }
        return This["class", string]
    }
    
    function table egpFocused() {
        return EGP_FOCUSED != notable() && EGP_FOCUSED:egpValid() ? EGP_FOCUSED : notable()
    }
    
    function number egpIsFocused() {
        return egpFocused() != notable() && egpFocused():egpValid()
    }
    
    function void egpFocusNone() {
        if(egpIsFocused()) {
            egpEvent("focus.exit", table(
                "target" = egpFocused()
            ))
        }
        EGP_FOCUSED = notable()
    }
    
    function void egpFocused(Element:table) {
        if(Element != egpFocused()) {
            egpFocusNone()
            EGP_FOCUSED = Element
            egpEvent("focus.enter", table(
                "target" = Element
            ))
        }
    }
    
    function table egpWindow(Name:string, Properties:table) {
        local Window = table(
            "class" = "Window",
            "type" = "box",
            "name" = Name,
            "position" = Properties:exists("position") ? Properties["position", table] : table("x" = 0, "y" = 0),
            "size" = Properties:exists("size") ? Properties["size", table] : table("width" = "100%", "height" = "100%"),
            "colour" = Properties:exists("colour") ? Properties["colour", vector4] : vec4(50, 50, 50, 255),
            "anchor" = Properties:exists("anchor") ? Properties["anchor", table] : table("x" = 0, "y" = 0),
            "children" = table()
        )
        
        if(Properties:exists("title")) {
            Window["children", table]:pushTable(
                table(
                    "type" = "box",
                    "name" = "header",
                    "size" = table(
                        "width" = "100%",
                        "height" = 25
                    ),
                    "colour" = vec4(100, 100, 100, 255),
                    "children" = table(
                        table(
                            "type" = "text",
                            "name" = "text",
                            "colour" = vec4(255, 255, 255, 255),
                            "text" = Properties["title", string],
                            "align" = vec2(1, 1)
                        )
                    )
                )
            )
        }
        
        egpBody():egpAdd(Window)
        return Window
    }
    
    function table egpWindow(Name:string) {
        return egpWindow(Name, table())
    }
    
    function table egpGetWindow(Name:string) {
        foreach(_:number, ElementWindow:table = EGP_WINDOWS) {
            if(ElementWindow:egpName() == Name) {
                return ElementWindow
            }
        }
        error("no window found")
    }
    
    function table table:egpBox(Position:table, Size:table) {
        if(This:egpClass() != "Window") {
            error("buttons can only be added to a window")
        }
        local Box = table(
            "class" = "box",
            "type" = "box",
            "colour" = vec4(50,50,50,255),
            "position" = Position,
            "size" = Size,
            "children" = table()
        )
        This:egpAdd(Box)
        return Box
    }
    
    function table table:egpButton(Name:string, Properties:table) {
        if(This:egpClass() != "Window") {
            error("buttons can only be added to a window")
        }
        local Button = table(
            "class" = "Button",
            "type" = "box",
            "name" = Name,
            "position" = Properties:exists("position") ? Properties["position", table] : table("x" = 0, "y" = 0),
            "size" = Properties:exists("size") ? Properties["size", table] : table("width" = 100, "height" = 25),
            "colour" = Properties:exists("colour") ? Properties["colour", vector4] : vec4(100, 100, 100, 255),
            "anchor" = Properties:exists("anchor") ? Properties["anchor", table] : table("x" = 0, "y" = 0),
            "children" = table(
                table(
                    "type" = "text",
                    "name" = "text",
                    "text" = Properties:exists("label") ? Properties["label", string] : "Button",
                    "colour" = vec4(255, 255, 255, 255),
                    "align" = vec2(1, 1)
                )
            ),
            "callbacks" = Properties["callbacks", array]
        )
        This:egpAdd(Button)
        return Button
    }
    
    function table table:egpCheckbox(Name:string, Properties:table) {
        if(This:egpClass() != "Window") {
            error("checkboxes can only be added to a window")
        }
        local Checkbox = table(
            "class" = "Checkbox",
            "type" = "box",
            "name" = Name,
            "position" = Properties:exists("position") ? Properties["position", table] : table("x" = 0, "y" = 0),
            "size" = vec2(25, 25),
            "colour" = Properties:exists("colour") ? Properties["colour", vector4] : vec4(100, 100, 100, 255),
            "anchor" = Properties:exists("anchor") ? Properties["anchor", table] : table("x" = 0, "y" = 0),
            "checked" = 0,
            "children" = table(
                table(
                    "type" = "box",
                    "name" = "checked",
                    "colour" = vec4(50, 50, 50, 0),
                    "position" = table(
                        "x" = "20%",
                        "y" = "20%"
                    ),
                    "size" = table(
                        "width" = "60%",
                        "height" = "60%"
                    )
                )
            ),
            "callbacks" = Properties["callbacks", array]
        )
        This:egpAdd(Checkbox)
        return Checkbox
    }
    
    function table table:egpInput(Name:string, Properties:table) {
        if(This:egpClass() != "Window") {
            error("inputs can only be added to a window")
        }
        
        local Placeholder = Properties:exists("placeholder") ? Properties["placeholder", string] : ""
        local Value = Properties:exists("value") ? Properties["value", string] : ""
        
        local Input = table(
            "class" = "Input",
            "type" = "box",
            "name" = Name,
            "position" = Properties:exists("position") ? Properties["position", table] : table("x" = 0, "y" = 0),
            "size" = Properties:exists("size") ? Properties["size", table] : table("width" = 100, "height" = 25),
            "colour" = Properties:exists("colour") ? Properties["colour", vector4] : vec4(100, 100, 100, 255),
            "anchor" = Properties:exists("anchor") ? Properties["anchor", table] : table("x" = 0, "y" = 0),
            "value" = Value,
            "placeholder" = Placeholder,
            "children" = table(
                table(
                    "type" = "text",
                    "name" = "value",
                    "position" = table(
                        "x" = "2.5%",
                        "y" = 0
                    ),
                    "size" = table(
                        "width" = "95%",
                        "height" = "100%"
                    ),
                    "text" = Value == "" ? Placeholder : Value,
                    "colour" = Value == "" ? vec4(150, 150, 150, 255) : vec4(255, 255, 255, 255),
                    "align" = vec2(0, 1)
                )
            ),
            "callbacks" = Properties["callbacks", table]
        )
        This:egpAdd(Input)
        return Input
    }
}

if(egpEventClk()) {
    if(egpEventClk("element.loaded")) {
        local Element = egpEventData()
        if(Element:egpClass() == "Window") {
            EGP_WINDOWS:pushTable(Element)
            egpEvent("window.loaded", table(
                "target" = Element
            ))
        }
    }
    
    if(egpEventClk("element.removed")) {
        local Element = egpEventData()
        
        if(EGP_FOCUSED == Element) {
            EGP_FOCUSED = notable()
        }
        
        for(I = EGP_WINDOWS:count(), 1, -1) {
            if(Element == EGP_WINDOWS[I, table]) {
                EGP_WINDOWS:remove(I)
                break
            }
        }
    }
    
    if(egpEventClk("mouse.press")) {
        local Event = egpEventData()
        local User = Event["user", entity]
        local Cursor = Event["cursor", vector2]
        
        for(I = EGP_WINDOWS:count(), 1, -1) {
            local ElementWindow = EGP_WINDOWS[I, table]
            if(ElementWindow:egpMouseOver(Cursor)) {
                egpEvent("window.press", table(
                    "target" = ElementWindow,
                    "user" = User,
                    "cursor" = Cursor
                ))
                break
            }
        }
    }
    
    if(egpEventClk("window.press")) {
        local Event = egpEventData()
        local Window = Event["target", table]
        local User = Event["user", entity]
        local Cursor = Event["cursor", vector2]
        
        if(Window:egpValid()) {
            foreach(_:number, ElementUI:table = Window:egpChildren()) {
                if(ElementUI:egpMouseOver(Cursor)) {
                    local Capture = 1
                    switch(ElementUI:egpClass()) {
                        case "Button",
                            egpEvent("button.press", table(
                                "target" = ElementUI,
                                "user" = User,
                                "cursor" = Cursor
                            ))
                        break
                        case "Checkbox",
                            egpEvent("checkbox.press", table(
                                "target" = ElementUI,
                                "user" = User,
                                "cursor" = Cursor
                            ))
                        break
                        case "Input",
                            egpEvent("input.press", table(
                                "target" = ElementUI,
                                "user" = User,
                                "cursor" = Cursor
                            ))
                        break
                        default,
                            Capture = 0
                        break
                    }
                    if(Capture) {
                        break
                    }
                }
            }
        }
    }
    
    if(egpEventClk("button.press")) {
        local Event = egpEventData()
        local Button = Event["target", table]
        local User = Event["user", entity]
        local Cursor = Event["cursor", vector2]
        local Callbacks = Button["properties", table]["callbacks", array]
        
        foreach(_:number, Callback:string = Callbacks) {
            egpEvent(Callback, table(
                "target" = Button,
                "user" = User,
                "cursor" = Cursor
            ))
        }
    }
    
    if(egpEventClk("checkbox.press")) {
        local Event = egpEventData()
        local ElementCheckbox = Event["target", table]
        local User = Event["user", entity]
        local Cursor = Event["cursor", vector2]
        local Callbacks = ElementCheckbox["properties", table]["callbacks", array]
        
        local Checked = !ElementCheckbox["properties", table]["check", number]
        ElementCheckbox["properties", table]["check", number] = Checked
        foreach(_:number, Callback:string = Callbacks) {
            egpEvent(Callback, table(
                "target" = ElementCheckbox,
                "user" = User,
                "cursor" = Cursor,
                "checked" = Checked
            ))
        }
        
        if(Checked) {
            ElementCheckbox:egpChild(1):egpColour(vec4(50, 50, 50, 255))
        } else {
            ElementCheckbox:egpChild(1):egpColour(vec4(50, 50, 50, 0))
        }
    }
    
    if(egpEventClk("input.press")) {
        local Event = egpEventData()
        local ElementInput = Event["target", table]
        local User = Event["user", entity]
        local Cursor = Event["cursor", vector2]
        local Callbacks = ElementInput["properties", table]["callbacks", table]
        
        egpFocused(ElementInput)
        
        foreach(_:number, Callback:string = Callbacks["focused", array]) {
            egpEvent(Callback, table(
                "target" = ElementInput,
                "user" = User,
                "cursor" = Cursor
            ))
        }
    }
    
    if(egpEventClk("keyboard.exit")) {
        egpFocusNone()
    }
    
    if(egpEventClk("keyboard.press")) {
        local Event = egpEventData()
        local KeyCode = Event["key", number]
        
        if(!egpIsFocused()) {
            if(KeyCode == 101) {
                egpMousePressEvent(Event["user", entity], Event["cursor", vector2])
            }
        } else {
            local Element = egpFocused()
            if(Element:egpClass() == "Input") {
                local ElementValue = Element:egpChild(1)
                local Properties = Element["properties", table]
                local Value = Properties["value", string]
                
                if(KeyCode == 9 || KeyCode == 10) {
                    egpFocusNone()
                } elseif(KeyCode == 149 || KeyCode == 150) {
                    if(KeyCode == 149) {
                        EGP_CURSOR = 0
                    } elseif(KeyCode == 150) {
                        EGP_CURSOR = Value:length()
                    }
                } else {
                    EGP_CURSOR_BLINK = 0
                    
                    #left
                    if(KeyCode == 19) {
                        EGP_CURSOR = max(EGP_CURSOR - 1, 0)
                        egpScreen():entity():soundPlay("checkbox", 0.1, "freeman/taserx26_click1.wav")
                    }
                    
                    #right
                    if(KeyCode == 20) {
                        EGP_CURSOR = min(EGP_CURSOR + 1, Value:length())
                        egpScreen():entity():soundPlay("checkbox", 0.1, "freeman/taserx26_click1.wav")
                    }
                    
                    local Changed = 0
                    #backspace
                    if(KeyCode == 127 && EGP_CURSOR > 0) {
                        Value = Value:sub(1, EGP_CURSOR - 1) + Value:sub(EGP_CURSOR + 1, Value:length())
                        EGP_CURSOR = max(EGP_CURSOR - 1, 0)
                        Changed = 1
                    }
                    
                    #delete
                    if(KeyCode == 148 && EGP_CURSOR < Value:length()) {
                        Value = Value:sub(1, EGP_CURSOR) + Value:sub(EGP_CURSOR + 2, Value:length())
                        Changed = 1
                    }
                    
                    if(inrange(KeyCode, 33, 126) || KeyCode == 32) {
                        Value = Value:sub(1, EGP_CURSOR) + toChar(KeyCode) + Value:sub(EGP_CURSOR + 1, Value:length())
                        EGP_CURSOR = min(EGP_CURSOR + 1, Value:length())
                        Changed = 1
                    }
                    
                    Properties["value", string] = Value
                    
                    if(Changed) {
                        local Callbacks = Element["properties", table]["callbacks", table]
                        foreach(_:number, Callback:string = Callbacks["changed", array]) {
                            egpEvent(Callback, table(
                                "target" = Element,
                                "value" = Value
                            ))
                        }
                        egpScreen():entity():soundPlay("checkbox", 0.1, "freeman/taserx26_click1.wav")
                    }
                }
                
                #update text
                local Text = toUnicodeChar(0x35F, toByte(" ")) + Value:sub(1, Value:length())
                if(EGP_CURSOR > 0) {
                    Text = Value:sub(1, EGP_CURSOR - 1) + toUnicodeChar(0x35F, toByte(Value, EGP_CURSOR)) + Value:sub(EGP_CURSOR + 1, Value:length())
                }
                ElementValue:egpText(Text:replace(" ", "  "))
            }
        }
        
        egpKeyboardClear()
    }
    
    if(egpEventClk("focus.enter")) {
        local Event = egpEventData()
        local Target = Event["target", table]
        
        if(Target:egpClass() == "Input") {
            local ElementValue = Target:egpChild(1)
            
            local Properties = Target["properties", table]
            local Value = Properties["value", string]
            
            EGP_CURSOR = Value:length()
            
            local Text = Value:sub(1, EGP_CURSOR - 1) + toUnicodeChar(0x35F, toByte(Value, EGP_CURSOR)) + Value:sub(EGP_CURSOR + 1, Value:length())
            ElementValue:egpText(Text:replace(" ", "  "))
            ElementValue:egpColour(vec4(255, 255, 255, 255))
            
            egpEventDelay("cursor.blink", table(
                "target" = Target,
                "blink" = 1
            ), 0)
        }
        egpKeyboardClear()
    }
    
    if(egpEventClk("cursor.blink")) {
        local Event = egpEventData()
        local Target = Event["target", table]
        local Blink = Event["blink", number]
        
        if(Target:egpValid() && Target == egpFocused()) {
            if(Target:egpClass() == "Input") {
                if(EGP_CURSOR_BLINK) {
                    local ElementValue = Target:egpChild(1)
                    
                    local Properties = Target["properties", table]
                    local Value = Properties["value", string]
                    
                    local Text = (Blink ? toUnicodeChar(0x35F, toByte(" ")) : " ") + Value:sub(1, Value:length())
                    if(EGP_CURSOR > 0) {
                        Text = Value:sub(1, EGP_CURSOR - 1) + (Blink ? toUnicodeChar(0x35F, toByte(Value, EGP_CURSOR)) : toChar(toByte(Value, EGP_CURSOR))) + Value:sub(EGP_CURSOR + 1, Value:length())
                    }
                    ElementValue:egpText(Text:replace(" ", "  "))
                }
                
                EGP_CURSOR_BLINK = 1
                egpEventDelay("cursor.blink", table(
                    "target" = Target,
                    "blink" = !Blink
                ), 800)
            }
        }
    }
    
    if(egpEventClk("focus.exit")) {
        local Event = egpEventData()
        local Target = Event["target", table]
        
        if(Target:egpValid()) {
            if(Target:egpClass() == "Input") {
                local ElementValue = Target:egpChild(1)
                
                local Properties = Target["properties", table]
                local Value = Properties["value", string]
                local Placeholder = Properties["placeholder", string]
                
                if(Value != "") {
                    ElementValue:egpText(Properties["value", string]:replace(" ", "  "))
                    ElementValue:egpColour(vec4(255, 255, 255, 255))
                } else {
                    if(Placeholder != "") {
                        ElementValue:egpText(Placeholder:replace(" ", "  "))
                        ElementValue:egpColour(vec4(150, 150, 150, 255))
                    }
                }
            }
        }
        
        EGP_CURSOR = 0
        EGP_CURSOR_BLINK = 0
        egpKeyboardClear()
    }
}



