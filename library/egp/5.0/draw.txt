@persist [EGP_FREE, EGP_USED]:array
@persist EGP_DRAW_INDEX:number
@persist EGP_DRAW_QUEUE:table
@persist EGP_SCREEN_WIDTH:number
@persist EGP_SCREEN_HEIGHT:number
@persist EGP_PATH:table
@persist EGP_BODY:table
@persist EGP_FONT:string
@persist EGP_DEBUG:number
@persist EGP_DEBUG_ID:number

#include "library/table"
#include "library/egp"
#include "library/property"
##include "library/egp/5.0/event"
##include "library/egp/5.0/input"

if(first() || dupefinished()) {
    EGP_FREE = array()
    EGP_USED = array()
    EGP_DRAW_INDEX = 1
    EGP_DRAW_QUEUE = table()
    EGP_SCREEN_WIDTH = 512
    EGP_SCREEN_HEIGHT = 512
    EGP_PATH = table()
    EGP_BODY = table()
    EGP_FONT = ""
    EGP_DEBUG = 0
    EGP_DEBUG_ID = 0
    
    #MEMORY: --------------------------------------------------------------------------------------------------------------------
    function number egpNew() {
        if(EGP_FREE:count() == 0) {
            local Total = (EGP_FREE:count() + EGP_USED:count()) + 1
            
            if(Total < egpMaxObjects()) {
                local Id = Total
                EGP_USED:pushNumber(Id)
                return Id
            }
        } else {
            local Id = EGP_FREE:removeNumber(1)
            EGP_USED:pushNumber(Id)
            return Id
        }
        
        return 0
    }
    
    function void egpFree(Id:number) {
        local LkupUsed = invert(EGP_USED)
        
        if(LkupUsed:exists(Id:toString())) {
            EGP_USED:removeNumber(LkupUsed[Id:toString(), number])
            EGP_FREE:pushNumber(Id)
            EGP_SCREEN:egpRemove(Id)
        }
    }
    
    #HELPERS: --------------------------------------------------------------------------------------------------------------------
    function number egpPixels(Value:number, _:number) {
        return Value
    }
    
    function number egpPixels(Value:string, Max:number) {
        local Absolute = Value:match("^(-*%d+)$")
        if(Absolute[1, string] == "") {
            Absolute = Value:match("^(-*%d+)px$")
        }
        
        if(Absolute[1, string] != "") {
            return Absolute[1, string]:toNumber()
        }
        
        local Percent = Value:match("^(-*%d+)%%$")
        if(Percent[1, string] == "") {
            Percent = Value:match("^(-*%d+%.%d+)%%$")
        }
        
        if(Percent[1, string] != "") {
            return ceil((Percent[1, string]:toNumber() / 100) * Max)
        }
        
        return 0
    }
    
    #EVENTS: --------------------------------------------------------------------------------------------------------------------
    function table egpDrawQueue() {
        return EGP_DRAW_QUEUE
    }
    
    function void egpDraw(Type:string, Data:table, Index:number) {
        egpEventPoll()
        
        egpDrawQueue():insertTable(Index, table(
            "type" = Type,
            "data" = Data
        ))
    }
    
    function void egpDraw(Type:string, Data:table) {
        egpDraw(Type, Data, 1)
    }
    
    function void egpDrawNext(Type:string, Data:table) {
        egpDraw(Type, Data, EGP_DRAW_INDEX)
    }
    
    #DRAWING: --------------------------------------------------------------------------------------------------------------------
    function string egpDefaultFont() {
        return EGP_FONT
    }
    
    function void egpDefaultFont(Font:string) {
        EGP_FONT = Font
    }
    
    function table egpBody() {
        return EGP_BODY
    }
    
    function table egpGet(Path:string) {
        if(!EGP_PATH:exists(Path)) {
            error("element('" + Path + "') not found")
        }
        return EGP_PATH[Path, table]
    }
    
    function number egpExists(Path:string) {
        return EGP_PATH:exists(Path)
    }
    
    function table table:egpParent() {
        if(!This:exists("parent")) {
            error("element has no parent")
        }
        return This["parent", table]
    }
    
    function number table:egpId() {
        return This["id", number]
    }
    
    function string table:egpPath() {
        return This["path", string]
    }
    
    function number table:egpIndex() {
        return This["index", number]
    }
    
    function string table:egpName() {
        return This["name", string]
    }
    
    function vector2 table:egpPos() {
        return vec2(EGP_SCREEN:egpGlobalPos(This:egpId()))
    }
    
    function number table:egpValid() {
        return This:egpId() != 0
    }
    
    function table table:egpChildren() {
        return This["children", table]["index", table]
    }
    
    function table table:egpChild(I:number) {
        local Children = This["children", table]["index", table]
        if(!Children:exists(I)) {
            error("child(" + I + ") not found in element")
        }
        
        return Children[I, table]
    }
    
    function table table:egpChild(Name:string) {
        local Children = This["children", table]["name", table]
        if(!Children:exists(Name)) {
            error("child(" + Name + ") not found in element")
        }
        
        return Children[Name, table]
    }
    
    function number table:egpExists(Name:string) {
        return This["children", table]["name", table]:exists(Name)
    }
    
    function table table:egpChildFirst() {
        try {
            return This:egpChild(1)
        } catch(_) {
            error("child(first) not found in element")
        }
    }
    
    function table table:egpChildLast() {
        local Children = This["children", table]["index", table]
        try {
            return This:egpChild(Children:count())
        } catch(_) {
            error("child(last) not found in element")
        }
    }
    
    function vector2 table:egpPos() {
        return vec2(egpScreen():egpGlobalPos(This:egpId()))
    }
    
    function void table:egpPos(Position:vector2) {
        This["properties", table]["position", vector2] = Position
        EGP_SCREEN:egpPos(This:egpId(), Position)
    }
    
    function void table:egpPos(Position:table) {
        This["properties", table]["position", table] = Position
        
        local ParentSize = vec2(EGP_SCREEN_WIDTH, EGP_SCREEN_HEIGHT)
        ParentSize = ParentSize
        try {
            ParentSize = EGP_SCREEN:egpSize(This:egpParent():egpId())
        } catch(_) {}
        
        local PositionData = Position
        local PositionTypeIds = PositionData:typeids()
        local X = PositionTypeIds["x", string] == "n" ? egpPixels(PositionData["x", number], ParentSize:x()) : egpPixels(PositionData["x", string], ParentSize:x())
        local Y = PositionTypeIds["y", string] == "n" ? egpPixels(PositionData["y", number], ParentSize:y()) : egpPixels(PositionData["y", string], ParentSize:y())
        
        EGP_SCREEN:egpPos(This:egpId(), vec2(X, Y) - This["anchor", vector2])
    }
    
    function void table:egpAnchor(Anchor:vector2) {
        This["properties", table]["anchor", vector2] = Anchor
        This["anchor", vector2] = Anchor
        This:egpPos(EGP_SCREEN:egpPos(This:egpId()))
    }
    
    function void table:egpAnchor(Anchor:table) {
        This["properties", table]["anchor", table] = Anchor
        
        local Id = This:egpId()
        local Size = EGP_SCREEN:egpSize(This:egpId())
        local AnchorTypeIds = Anchor:typeids()
        local AX = AnchorTypeIds["x", string] == "n" ? egpPixels(Anchor["x", number], Size:x()) : egpPixels(Anchor["x", string], Size:x())
        local AY = AnchorTypeIds["y", string] == "n" ? egpPixels(Anchor["y", number], Size:y()) : egpPixels(Anchor["y", string], Size:y())
        
        This["anchor", vector2] = vec2(AX, AY)
        This:egpPos(EGP_SCREEN:egpPos(Id))
    }
    
    function vector2 table:egpSize() {
        return egpScreen():egpSize(This:egpId())
    }
    
    function table:egpSize(Size:vector2) {
        This["properties", table]["size", vector2] = Size
        egpDrawNext("draw", table("target" = This, "children" = 1))
    }
    
    function table:egpSize(Size:table) {
        This["properties", table]["size", table] = Size
        egpDrawNext("draw", table("target" = This, "children" = 1))
    }
    
    function void table:egpColour(Colour:vector4) {
        EGP_SCREEN:egpColor(This:egpId(), Colour)
        This["properties", table]["colour", vector4] = Colour
    }
    
    function vector4 table:egpColour() {
        return This["properties", table]["colour", vector4]
    }
    
    function void table:egpText(Text:string) {
        EGP_SCREEN:egpSetText(This:egpId(), Text)
        This["properties", table]["text", string] = Text
    }
    
    function string table:egpText() {
        return This["properties", table]["text", string]
    }
    
    function void table:egpMaterial(Material:string) {
        EGP_SCREEN:egpMaterial(This:egpId(), Material)
        This["properties", table]["material", string] = Material
    }
    
    function string table:egpMaterial() {
        return This["properties", table]["material", string]
    }
    
    function void table:egpAdd(Properties:table) {
        egpDrawNext("add", table("target" = This, "properties" = Properties))
    }
    
    function void table:egpRemove() {
        if(!EGP_DEBUG) {
            EGP_SCREEN:egpPos(This:egpId(), vec2(9999,9999))
        }
        egpDrawNext("remove", table("target" = This))
    }
    
    function table:egpList(List:table, Method:string, Start:number, Max:number, Spacing:number, Vertical:number) {
        local Hide = This:egpChildren():count() == 0
        if(Hide && !EGP_DEBUG) {
            EGP_SCREEN:egpPos(This:egpId(), vec2(9999, 99999))
        }
        
        if(This:egpChildren():count() > List:count()) {
            for(I = This:egpChildren():count(), List:count() + 1, -1) {
                This:egpChild(I):egpRemove()
            }
        }
        
        local Size = ((Vertical ? This:egpSize():y() : This:egpSize():x()) - (Max - 1) * Spacing) / Max
        for(I = 1, min(List:count(), Max)) {
            local ListItem = List[(Start - 1) + I, table]
            local A = ((I - 1) * Size) + ((I - 1) * Spacing)
            
            if(I <= This:egpChildren():count()) {
                Method(This:egpChild(I), ListItem, I, List, A, Size)[table]
            } else {
                This:egpAdd(Method(notable(), ListItem, I, List, A, Size)[table])
            }
        }
        
        if(Hide && !EGP_DEBUG) {
            egpDrawNext("draw", table("target" = This, "children" = 0)) #move back to pos
        }
    }
    
    function table:egpList(List:table, Method:string, Start:number, Max:number, Spacing:number) {
        This:egpList(List, Method, Start, Max, Spacing, 1)
    }
    
    function table:egpListItem(Method:string, Item:table) {
        Method(This, Item, This["index", number], notable(), This:egpPos():y(), This:egpSize():y())[table]
    }
    
    function void table:egpDrawProperties() {
        local TypeIds = This:typeids()
        
        local Type = This:setProperty(TypeIds, "type", "box", 0)
        This:setProperty(TypeIds, "name", Type, 0)
        
        if(!This:exists("position")) {
            This:setProperty(TypeIds, "position", vec2(), 0)
        } else {
            if(TypeIds["position", string] == "t") {
                This:setProperty(TypeIds, "position", table("x" = 0, "y" = 0), 0)
            } elseif(TypeIds["position", string] != "xv2") {
                This:setProperty(TypeIds, "position", vec2(), 0)
            }
        }
        
        if(!This:exists("size")) {
            This:setProperty(TypeIds, "size", table("width" = "100%", "height" = "100%"), 0)
        } else {
            if(TypeIds["size", string] == "t") {
                This:setProperty(TypeIds, "size", table("width" = "100%", "height" = "100%"), 0)
            } elseif(TypeIds["size", string] != "xv2") {
                This:setProperty(TypeIds, "size", vec2(), 0)
            }
        }
        
        if(!This:exists("events")) {
            This:setProperty(TypeIds, "events", table(), 0)
        }
        
        This:setProperty(TypeIds, "colour", vec4(), 0)
        This:setProperty(TypeIds, "angle", 0, 0)
        This:setProperty(TypeIds, "rounded", 0, Type != "box")
        This:setProperty(TypeIds, "outline", 0, Type != "box" && Type != "circle")
        This:setProperty(TypeIds, "thickness", 0, Type != "box" && Type != "circle")
        This:setProperty(TypeIds, "material", "", Type != "box")
        
        This:setProperty(TypeIds, "text", "", Type != "text")
        This:setProperty(TypeIds, "font", table("font" = "", "size" = 18), Type != "text")
        This:setProperty(TypeIds, "align", vec2(0,0), Type != "text")
    }
    
    function void table:egpDraw() {
        local Id = This["id", number]
        if(Id == 0) {
            This["id", number] = egpNew()
        }
        Id = This["id", number]
        
        local Properties = This["properties", table]
        Properties:egpDrawProperties()
        
        #TYPE ------------------------------------------------------------------------:
        local Type = Properties["type", string]
        if(!EGP_SCREEN:egpHasObject(Id) || (EGP_SCREEN:egpHasObject(Id) && EGP_SCREEN:egpObjectType(Id) != Type)) {
            switch(Type) {
                case "box",
                    local Outline = Properties["outline", number]
                    local Rounded = Properties["rounded", number]
                    
                    if(Outline && Rounded) {
                        EGP_SCREEN:egpRoundedBoxOutline(Id, vec2(), vec2())
                    } elseif(Rounded) {
                        EGP_SCREEN:egpRoundedBox(Id, vec2(), vec2())
                    } elseif(Outline) {
                        EGP_SCREEN:egpBoxOutline(Id, vec2(), vec2())
                    } else {
                        EGP_SCREEN:egpBox(Id, vec2(), vec2())
                    }
                break
                case "circle",
                    local Outline = Properties["outline", number]
                    
                    if(Outline) {
                        EGP_SCREEN:egpCircleOutline(Id, vec2(), vec2())
                    } else {
                        EGP_SCREEN:egpCircle(Id,vec2(), vec2())
                    }
                break
                case "text",
                    EGP_SCREEN:egpTextLayout(Id, "", vec2(), vec2())
                break
            }
        }
        
        #PATHS AND NAMING ------------------------------------------------------------------------:
        local Name = Properties["name", string]
        
        #name changed, need to update paths
        if(This["name", string] != "" && This["name", string] != Name) {
            #TODO: update all children
            This["name", string] = Name
        }
        
        if(This["name", string] == "" || This["name", string] != Name) {
            This["name", string] = Name
        }
        
        local ParentId = 0
        try {
            local Parent = This:egpParent()
            ParentId = Parent:egpId()
            
            local ChildrenByName = Parent["children", table]["name", table]
            ChildrenByName[Name, table] = This 
            
            if(Name != "") {
                local Path = (Parent["path", string] == "" ? "" : Parent["path", string] + ".") + Parent["name", string]
                if(This["path", string] != "") {
                    if(EGP_PATH:exists(This["path", string])) {
                        if(This["path", string] != Path) {
                            EGP_PATH:removeTable(This["path", string])
                        }
                    }
                }
                
                This["path", string] = Path
                
                local FullPath = Path + "." + Name
                EGP_PATH[FullPath, table] = This
            }
            
            if(EGP_SCREEN:egpParent(Id) != ParentId) {
                EGP_SCREEN:egpParent(Id, ParentId)
            }
        } catch(_) {}
        
        local TypeIds = Properties:typeids()
        
        local ParentSize = vec2(EGP_SCREEN_WIDTH, EGP_SCREEN_HEIGHT)
        if(ParentId > 0) {
            ParentSize = EGP_SCREEN:egpSize(ParentId)
        }
        
         #SIZE ------------------------------------------------------------------------:
        local SizeData = Properties["size", table]
        local W = 0
        local H = 0
        if(TypeIds["size", string] == "xv2") {
            local Size = Properties["size", vector2]
            W = Size:x()
            H = Size:y()
        } elseif(TypeIds["size", string] == "t") {
            local SizeTypesIds = SizeData:typeids()
            W = SizeTypesIds["width", string] == "n" ? egpPixels(SizeData["width", number], ParentSize:x()) : egpPixels(SizeData["width", string], ParentSize:x())
            H = SizeTypesIds["height", string] == "n" ? egpPixels(SizeData["height", number], ParentSize:y()) : egpPixels(SizeData["height", string], ParentSize:y())
        }
        
        This["size", vector2] = vec2(W, H)
        EGP_SCREEN:egpSize(Id, vec2(W, H))
        
        #POSITION ------------------------------------------------------------------------:
        local X = 0
        local Y = 0
        if(TypeIds["position", string] == "xv2") {
            local Position = Properties["position", vector2]
            X = Position:x()
            Y = Position:y()
        } elseif(TypeIds["position", string] == "t") {
            local PositionData = Properties["position", table]
            local PositionTypeIds = PositionData:typeids()
            X = PositionTypeIds["x", string] == "n" ? egpPixels(PositionData["x", number], ParentSize:x()) : egpPixels(PositionData["x", string], ParentSize:x())
            Y = PositionTypeIds["y", string] == "n" ? egpPixels(PositionData["y", number], ParentSize:y()) : egpPixels(PositionData["y", string], ParentSize:y())
        }
        
        #ANCHOR:
        local AX = 0
        local AY = 0
        if(TypeIds["anchor", string] == "xv2") {
            local Anchor = Properties["anchor", vector2]
            AX = Anchor:x()
            AY = Anchor:y()
        } elseif(TypeIds["anchor", string] == "t") {
            local AnchorData = Properties["anchor", table]
            local AnchorTypeIds = AnchorData:typeids()
            AX = AnchorTypeIds["x", string] == "n" ? egpPixels(AnchorData["x", number], W) : egpPixels(AnchorData["x", string], W)
            AY = AnchorTypeIds["y", string] == "n" ? egpPixels(AnchorData["y", number], H) : egpPixels(AnchorData["y", string], H)
        }
        
        This["anchor", vector2] = vec2(AX, AY)
        EGP_SCREEN:egpPos(Id, vec2(X, Y) - vec2(AX, AY))
        
        if(EGP_DEBUG_ID > 0) {
            EGP_SCREEN:egpBoxOutline(EGP_DEBUG_ID, vec2(EGP_SCREEN:egpGlobalPos(Id)), vec2(W, H))
            EGP_SCREEN:egpColor(EGP_DEBUG_ID, vec(255, 0, 0))
            EGP_SCREEN:egpOrderAbove(EGP_DEBUG_ID, Id)
        }
        
        #COLOUR ------------------------------------------------------------------------:
        local Colour = Properties["colour", vector4]
        EGP_SCREEN:egpColor(Id, Colour)
        
        #ANGLE
        local Angle = Properties["angle", number]
        EGP_SCREEN:egpAngle(Id, Angle)
        
        #MATERIAL ------------------------------------------------------------------------:
        EGP_SCREEN:egpMaterial(Id, Properties["material", string])
        
        #THICKNESS ------------------------------------------------------------------------:
        if(Properties["outline", number] == 1 && Properties["thickness", number] > 0) {
            EGP_SCREEN:egpSize(Id, Properties["thickness", number])
        }
        
        #TEXT ------------------------------------------------------------------------:
        if(Type == "text") {
            local Font = Properties["font", table]
            local FontName = Font["font", string]
            local FontSize = 18
            local Align = Properties["align", vector2]
            
            local FontTypeIds = Font:typeids()
            if(FontTypeIds["size", string] == "s") {
                FontSize = egpPixels(Font["size", string], H)
            } else {
               FontSize = Font["size", number]
            }
            
            EGP_SCREEN:egpSetText(Id, Properties["text", string])
            EGP_SCREEN:egpFont(Id, FontName != "" ? FontName : egpDefaultFont(), FontSize > 0 ? FontSize : H)
            EGP_SCREEN:egpAlign(Id, Align:x(), Align:y())
        }
    }
    
    function void egpDrawClear(Width:number, Height:number) {
        EGP_FREE = array()
        EGP_USED = array()
        EGP_DRAW_INDEX = 1
        EGP_DRAW_QUEUE = table()
        EGP_PATH = table()
        if(EGP_DEBUG) {
            EGP_DEBUG_ID = egpNew()
        }
        EGP_SCREEN_WIDTH = Width
        EGP_SCREEN_HEIGHT = Height
        
        EGP_BODY = table(
            "id" = 0,
            "index" = 0,
            "name" = "",
            "path" = "",
            "size" = vec2(EGP_SCREEN_WIDTH, EGP_SCREEN_HEIGHT),
            "children" = table(
                "index" = table(),
                "name" = table()
            ),
            "properties" = table(
                "name" = "body",
                "type" = "box",
                "anchor" = table(
                    "x" = "50%",
                    "y" = "50%"
                ),
                "position" = table(
                    "x" = "50%",
                    "y" = "50%"
                ),
                "size" = vec2(EGP_SCREEN_WIDTH, EGP_SCREEN_HEIGHT)
            )
        )
        EGP_BODY:egpDraw()
        EGP_FONT = "WireGPU_ConsoleFont"
    }
    
    function void table:egpProcessDraw() {
        EGP_DRAW_INDEX = egpDrawQueue():count() + 1
        
        local Type = This["type", string]
        local Data = This["data", table]
        
        switch(Type) {
            case "add",
                if(Data:exists("target")) {
                    local Properties = Data["properties", table]
                    local Parent = Data["target", table]
                    
                    local Children = Parent:egpChildren()
                    local Target = table(
                        "parent" = Parent,
                        "id" = egpNew(),
                        "index" = Children:count() + 1,
                        "name" = "",
                        "path" = "",
                        "position" = vec2(0, 0),
                        "size" = vec2(0, 0),
                        "children" = table(
                            "index" = table(),
                            "name" = table()
                        ),
                        "properties" = Properties
                    )
                    Children:pushTable(Target)
                    Target:egpDraw()
                    
                    if(Properties["events", table]:exists("loaded")) {
                        egpEvent(Properties["events", table]["loaded", string], table("target" = Target), 1)
                    }
                    
                    if(Properties:exists("children")) {
                        for(I = 1, Properties["children", table]:count()) {
                            egpDrawNext("add", table("target" = Target, "properties" = Properties["children", table][I, table]))
                        }
                        Properties:remove("children")
                    }
                    
                    #only do this if no debugging
                    if(!EGP_DEBUG) {
                        #move the object far away so it's not seen being rendered
                        EGP_SCREEN:egpPos(Target:egpId(), vec2(9999,9999))
                        egpDrawNext("draw", table("target" = Target, "children" = 0)) #re-draw to unhide
                    }
                }
            break
            case "draw",
                local Target = Data["target", table]
                Target:egpDraw()
                
                if(Data["children", number] == 1) {
                    foreach(_:number, Child:table = Data:egpChildren()) {
                        egpDrawNext("draw", Child)
                    }
                }
            break
            case "remove",
                local Target = Data["target", table]
                
                if(Data:exists("remove")) {
                    local Properties = Target["properties", table]
                    
                    local Parent = Target:egpParent()
                    local Children = Parent:egpChildren()
                    Children:remove(Target:egpIndex())
                    
                    for(I = Target:egpIndex(), Children:count()) {
                        Children[I, table]["index", number] = I
                    }
                    
                    local ChildrenByName = Parent["children", table]["name", table]
                    local Name = Target:egpName()
                    if(Name != "") {
                        if(ChildrenByName:exists(Name)) {
                            ChildrenByName:remove(Name)
                        }
                    }
                    
                    local Path = Target:egpPath() + "." + Target:egpName()
                    if(EGP_PATH:exists(Path)) {
                        EGP_PATH:remove(Path)
                    }
                    
                    if(Properties["events", table]:exists("removed")) {
                        egpEvent(Properties["events", table]["removed", string], table("target" = Target), 1)
                    }
                    
                    egpFree(Target:egpId())
                    Target["id", number] = 0
                } else {
                    Data["remove", number] = 1
                    
                    #move the object far away so it's not seen being removed
                    EGP_SCREEN:egpPos(Target:egpId(), vec2(9999,9999))
                    
                    foreach(_:number, Child:table = Target:egpChildren()) {
                        egpDrawNext("remove", table(
                            "target" = Child
                        ))
                    }
                    
                    egpDrawNext("remove", table(
                        "target" = Target,
                        "remove" = 1
                    ))
                }
            break
            default,
            break
        }
    }
}
